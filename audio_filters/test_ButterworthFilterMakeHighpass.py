# ********RoostGPT********
"""
Test generated by RoostGPT for test python-unit--test using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=make_highpass_82938f5d7d
ROOST_METHOD_SIG_HASH=make_highpass_82938f5d7d

================================VULNERABILITIES================================
Vulnerability: Input Validation
Issue: The function 'make_highpass' does not validate the input parameters. This can lead to unexpected behavior or crashes if incorrect values are passed.
Solution: Check the input parameters for validity. For example, ensure the 'frequency' and 'samplerate' are positive integers, and 'q_factor' is a positive float.

Vulnerability: Dependency Security
Issue: The code relies on a third-party package 'audio_filters'. If this package has vulnerabilities or is not maintained, it can expose the application to risks.
Solution: Ensure 'audio_filters' package is up-to-date and maintained by a reputable source. Consider alternatives if the package is deprecated or unmaintained.

================================================================================
Scenario 1: Validate the creation of a high-pass filter with default q_factor
Details:
  TestName: test_make_highpass_default_q_factor
  Description: This test will verify if the make_highpass function creates an IIRFilter object with the correct coefficients when the q_factor is not explicitly specified (default value is used).
Execution:
  Arrange: Initialize frequency and samplerate values.
  Act: Call the make_highpass function with the frequency and samplerate values.
  Assert: Check if the returned IIRFilter object has the correct coefficients.
Validation:
  This test validates the default behavior of the make_highpass function. It ensures that the function can correctly produce a high-pass filter with the correct coefficients when the q_factor is left to its default value.

Scenario 2: Validate the creation of a high-pass filter with a specified q_factor
Details:
  TestName: test_make_highpass_specified_q_factor
  Description: This test will verify if the make_highpass function creates an IIRFilter object with the correct coefficients when the q_factor is explicitly specified.
Execution:
  Arrange: Initialize frequency, samplerate, and q_factor values.
  Act: Call the make_highpass function with the frequency, samplerate, and q_factor values.
  Assert: Check if the returned IIRFilter object has the correct coefficients.
Validation:
  This test validates the behavior of the make_highpass function when a specific q_factor is provided. It ensures that the function correctly accounts for the q_factor in the creation of the high-pass filter.

Scenario 3: Validate the behavior of make_highpass function with zero frequency
Details:
  TestName: test_make_highpass_zero_frequency
  Description: This test will verify if the make_highpass function handles the case where the frequency is zero.
Execution:
  Arrange: Initialize frequency to zero, and a valid samplerate value.
  Act: Call the make_highpass function with the frequency and samplerate values.
  Assert: Check if the returned IIRFilter object has the correct coefficients.
Validation:
  This test is important because it checks how the function handles edge cases. In this case, the edge case is a frequency of zero.

Scenario 4: Validate the behavior of make_highpass function with zero samplerate
Details:
  TestName: test_make_highpass_zero_samplerate
  Description: This test will verify if the make_highpass function handles the case where the samplerate is zero.
Execution:
  Arrange: Initialize a valid frequency value and samplerate to zero.
  Act: Call the make_highpass function with the frequency and samplerate values.
  Assert: Check if the function raises an appropriate exception.
Validation:
  This test is important because it checks how the function handles edge cases. In this case, the edge case is a samplerate of zero. The function should handle this gracefully, likely by raising an exception, as division by zero is undefined.

Scenario 5: Validate the behavior of make_highpass function with negative q_factor
Details:
  TestName: test_make_highpass_negative_q_factor
  Description: This test will verify if the make_highpass function handles the case where the q_factor is negative.
Execution:
  Arrange: Initialize frequency, samplerate, and q_factor (negative value) values.
  Act: Call the make_highpass function with the frequency, samplerate, and q_factor values.
  Assert: Check if the function raises an appropriate exception.
Validation:
  This test is important because it checks how the function handles edge cases. In this case, the edge case is a negative q_factor. The function should handle this gracefully, likely by raising an exception, as a negative q_factor is not valid in this context.
"""

# ********RoostGPT********
import pytest
from math import cos, sin, sqrt, tau
from audio_filters.iir_filter import IIRFilter
from butterworth_filter import make_highpass

class Test_ButterworthFilterMakeHighpass:
    
    @pytest.mark.parametrize("frequency, samplerate", [(1000, 48000)])
    def test_make_highpass_default_q_factor(self, frequency, samplerate):
        filter = make_highpass(frequency, samplerate)
        assert isinstance(filter, IIRFilter)
        w0 = tau * frequency / samplerate
        _sin = sin(w0)
        _cos = cos(w0)
        alpha = _sin / (2 * sqrt(2))  # default q_factor is 1 / sqrt(2)
        b0 = (1 + _cos) / 2
        b1 = -1 - _cos
        a0 = 1 + alpha
        a1 = -2 * _cos
        a2 = 1 - alpha
        assert filter.a_coeffs == pytest.approx([a0, a1, a2], abs=1e-6)
        assert filter.b_coeffs == pytest.approx([b0, b1, b0], abs=1e-6)

    @pytest.mark.parametrize("frequency, samplerate, q_factor", [(1000, 48000, 0.7)])
    def test_make_highpass_specified_q_factor(self, frequency, samplerate, q_factor):
        filter = make_highpass(frequency, samplerate, q_factor)
        assert isinstance(filter, IIRFilter)
        w0 = tau * frequency / samplerate
        _sin = sin(w0)
        _cos = cos(w0)
        alpha = _sin / (2 * q_factor)
        b0 = (1 + _cos) / 2
        b1 = -1 - _cos
        a0 = 1 + alpha
        a1 = -2 * _cos
        a2 = 1 - alpha
        assert filter.a_coeffs == pytest.approx([a0, a1, a2], abs=1e-6)
        assert filter.b_coeffs == pytest.approx([b0, b1, b0], abs=1e-6)

    @pytest.mark.parametrize("frequency, samplerate", [(0, 48000)])
    def test_make_highpass_zero_frequency(self, frequency, samplerate):
        filter = make_highpass(frequency, samplerate)
        assert isinstance(filter, IIRFilter)
        w0 = tau * frequency / samplerate
        _sin = sin(w0)
        _cos = cos(w0)
        alpha = _sin / (2 * sqrt(2))  # default q_factor is 1 / sqrt(2)
        b0 = (1 + _cos) / 2
        b1 = -1 - _cos
        a0 = 1 + alpha
        a1 = -2 * _cos
        a2 = 1 - alpha
        assert filter.a_coeffs == pytest.approx([a0, a1, a2], abs=1e-6)
        assert filter.b_coeffs == pytest.approx([b0, b1, b0], abs=1e-6)

    @pytest.mark.parametrize("frequency, samplerate", [(1000, 0)])
    def test_make_highpass_zero_samplerate(self, frequency, samplerate):
        with pytest.raises(ZeroDivisionError):
            make_highpass(frequency, samplerate)

    @pytest.mark.parametrize("frequency, samplerate, q_factor", [(1000, 48000, -0.7)])
    def test_make_highpass_negative_q_factor(self, frequency, samplerate, q_factor):
        with pytest.raises(ValueError):
            make_highpass(frequency, samplerate, q_factor)

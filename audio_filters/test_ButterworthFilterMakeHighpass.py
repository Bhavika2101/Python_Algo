# ********RoostGPT********
"""
Test generated by RoostGPT for test python-unit--test using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=make_highpass_82938f5d7d
ROOST_METHOD_SIG_HASH=make_highpass_82938f5d7d

Scenario 1: Test high-pass filter creation with valid frequency, samplerate and q_factor
Details:
  TestName: test_make_highpass_with_valid_params
  Description: This test is intended to verify the successful creation of a high-pass filter when the function make_highpass is provided with valid frequency, samplerate and q_factor.
Execution:
  Arrange: Initialize valid frequency, samplerate and q_factor.
  Act: Invoke the make_highpass function with the initialized parameters.
  Assert: Check if the returned IIRFilter object has valid a_coeffs and b_coeffs.
Validation:
  This test is important to ensure that the function correctly creates a high-pass filter with the given parameters. The expected outcome is that the function returns an IIRFilter object with valid coefficients.

Scenario 2: Test high-pass filter creation with zero frequency
Details:
  TestName: test_make_highpass_with_zero_frequency
  Description: This test is intended to verify the behavior of the make_highpass function when a frequency of 0 is provided.
Execution:
  Arrange: Initialize a frequency of 0, and valid samplerate and q_factor.
  Act: Invoke the make_highpass function with the initialized parameters.
  Assert: Check if the returned IIRFilter object has valid a_coeffs and b_coeffs.
Validation:
  This test is important to ensure that the function correctly handles a frequency of 0. The expected outcome is that the function returns an IIRFilter object with valid coefficients.

Scenario 3: Test high-pass filter creation with negative frequency
Details:
  TestName: test_make_highpass_with_negative_frequency
  Description: This test is intended to verify the behavior of the make_highpass function when a negative frequency is provided.
Execution:
  Arrange: Initialize a negative frequency, and valid samplerate and q_factor.
  Act: Invoke the make_highpass function with the initialized parameters.
  Assert: Check if the function raises an appropriate error.
Validation:
  This test is important to ensure that the function correctly handles a negative frequency. The expected outcome is that the function raises an error, as a negative frequency is not a valid input.

Scenario 4: Test high-pass filter creation with frequency greater than samplerate
Details:
  TestName: test_make_highpass_with_frequency_greater_than_samplerate
  Description: This test is intended to verify the behavior of the make_highpass function when the frequency is greater than the samplerate.
Execution:
  Arrange: Initialize a frequency greater than the samplerate, and a valid q_factor.
  Act: Invoke the make_highpass function with the initialized parameters.
  Assert: Check if the function raises an appropriate error.
Validation:
  This test is important to ensure that the function correctly handles a scenario where the frequency is greater than the samplerate. The expected outcome is that the function raises an error, as this is not a valid scenario in digital signal processing.

Scenario 5: Test high-pass filter creation with zero q_factor
Details:
  TestName: test_make_highpass_with_zero_q_factor
  Description: This test is intended to verify the behavior of the make_highpass function when a q_factor of 0 is provided.
Execution:
  Arrange: Initialize a q_factor of 0, and valid frequency and samplerate.
  Act: Invoke the make_highpass function with the initialized parameters.
  Assert: Check if the function raises an appropriate error.
Validation:
  This test is important to ensure that the function correctly handles a q_factor of 0. The expected outcome is that the function raises an error, as a q_factor of 0 is not a valid input.
"""

# ********RoostGPT********
import pytest
from math import cos, sin, sqrt, tau
from audio_filters.iir_filter import IIRFilter
from audio_filters.butterworth_filter import make_highpass

class Test_ButterworthFilterMakeHighpass:
    @pytest.mark.smoke
    def test_make_highpass_with_valid_params(self):
        # Arrange
        frequency = 1000
        samplerate = 48000
        q_factor = 1 / sqrt(2)
        
        # Act
        filter = make_highpass(frequency, samplerate, q_factor)
        
        # Assert
        assert isinstance(filter, IIRFilter)
        assert len(filter.a_coeffs) == 3
        assert len(filter.b_coeffs) == 3

    def test_make_highpass_with_zero_frequency(self):
        # Arrange
        frequency = 0
        samplerate = 48000
        q_factor = 1 / sqrt(2)
        
        # Act
        filter = make_highpass(frequency, samplerate, q_factor)
        
        # Assert
        assert isinstance(filter, IIRFilter)
        assert len(filter.a_coeffs) == 3
        assert len(filter.b_coeffs) == 3

    def test_make_highpass_with_negative_frequency(self):
        # Arrange
        frequency = -1
        samplerate = 48000
        q_factor = 1 / sqrt(2)
        
        # Act & Assert
        with pytest.raises(ValueError):
            make_highpass(frequency, samplerate, q_factor)

    def test_make_highpass_with_frequency_greater_than_samplerate(self):
        # Arrange
        frequency = 50000
        samplerate = 48000
        q_factor = 1 / sqrt(2)
        
        # Act & Assert
        with pytest.raises(ValueError):
            make_highpass(frequency, samplerate, q_factor)

    def test_make_highpass_with_zero_q_factor(self):
        # Arrange
        frequency = 1000
        samplerate = 48000
        q_factor = 0
        
        # Act & Assert
        with pytest.raises(ValueError):
            make_highpass(frequency, samplerate, q_factor)

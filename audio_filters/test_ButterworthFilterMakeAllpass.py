# ********RoostGPT********
"""
Test generated by RoostGPT for test python-unit--test using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=make_allpass_aa18b576e9
ROOST_METHOD_SIG_HASH=make_allpass_aa18b576e9

================================VULNERABILITIES================================
Vulnerability: Insecure Dependency
Issue: The code uses a third party library (audio_filters.iir_filter). If the library has vulnerabilities or is compromised, it can lead to security issues.
Solution: Ensure that the third party library is trusted, maintained, and up-to-date. Regularly check for updates and patches in the library. If possible, use a vulnerability scanner to check for known vulnerabilities.

Vulnerability: Input Validation
Issue: The function 'make_allpass' does not validate the input parameters. If the function is exposed to a user interface, an attacker could pass malicious input to exploit the application.
Solution: Validate the input parameters 'frequency', 'samplerate', and 'q_factor' to make sure they are of correct type and within expected range. Raise appropriate exceptions if the validation fails.

================================================================================
Scenario 1: Validating the creation of an all-pass filter with default q_factor.
Details:
  TestName: test_make_allpass_default_qfactor
  Description: This test is intended to verify that the make_allpass function correctly creates an all-pass filter with the default q_factor.
Execution:
  Arrange: Initialize the frequency and samplerate variables.
  Act: Invoke the make_allpass function with the initialized variables.
  Assert: Verify that the returned IIRFilter object has the correct a_coeffs and b_coeffs.
Validation:
  The correct creation of an all-pass filter is crucial for audio processing tasks. This test ensures that the filter is correctly created with default parameters.

Scenario 2: Validating the creation of an all-pass filter with custom q_factor.
Details:
  TestName: test_make_allpass_custom_qfactor
  Description: This test is intended to verify that the make_allpass function correctly creates an all-pass filter with a custom q_factor.
Execution:
  Arrange: Initialize the frequency, samplerate and q_factor variables.
  Act: Invoke the make_allpass function with the initialized variables.
  Assert: Verify that the returned IIRFilter object has the correct a_coeffs and b_coeffs.
Validation:
  Different audio processing tasks may require a custom q_factor. This test ensures that the filter is correctly created with custom parameters.

Scenario 3: Validating the behavior of the function with frequency equal to zero.
Details:
  TestName: test_make_allpass_zero_frequency
  Description: This test is intended to verify the behavior of the make_allpass function when frequency is zero.
Execution:
  Arrange: Initialize the frequency (zero), samplerate and q_factor variables.
  Act: Invoke the make_allpass function with the initialized variables.
  Assert: Verify that the function behaves as expected (e.g., returns an appropriate error).
Validation:
  This test is important as it checks the function's robustness and its ability to handle edge case inputs.

Scenario 4: Validating the behavior of the function with samplerate equal to zero.
Details:
  TestName: test_make_allpass_zero_samplerate
  Description: This test is intended to verify the behavior of the make_allpass function when samplerate is zero.
Execution:
  Arrange: Initialize the frequency, samplerate (zero) and q_factor variables.
  Act: Invoke the make_allpass function with the initialized variables.
  Assert: Verify that the function behaves as expected (e.g., returns an appropriate error).
Validation:
  This test is important as it checks the function's robustness and its ability to handle edge case inputs.

Scenario 5: Validating the behavior of the function with q_factor equal to zero.
Details:
  TestName: test_make_allpass_zero_qfactor
  Description: This test is intended to verify the behavior of the make_allpass function when q_factor is zero.
Execution:
  Arrange: Initialize the frequency, samplerate and q_factor (zero) variables.
  Act: Invoke the make_allpass function with the initialized variables.
  Assert: Verify that the function behaves as expected (e.g., returns an appropriate error).
Validation:
  This test is important as it checks the function's robustness and its ability to handle edge case inputs.
"""

# ********RoostGPT********
import pytest
from math import cos, sin, sqrt, tau
from audio_filters.iir_filter import IIRFilter
from butterworth_filter import make_allpass

class Test_ButterworthFilterMakeAllpass:
    
    @pytest.mark.smoke
    @pytest.mark.positive
    def test_make_allpass_default_qfactor(self):
        frequency = 1000
        samplerate = 48000
        filter = make_allpass(frequency, samplerate)
        w0 = tau * frequency / samplerate
        _sin = sin(w0)
        _cos = cos(w0)
        alpha = _sin / (2 * (1 / sqrt(2)))
        b0 = 1 - alpha
        b1 = -2 * _cos
        b2 = 1 + alpha
        assert filter.a_coeffs == [b2, b1, b0]
        assert filter.b_coeffs == [b0, b1, b2]
        
    @pytest.mark.regression
    @pytest.mark.positive
    def test_make_allpass_custom_qfactor(self):
        frequency = 1000
        samplerate = 48000
        q_factor = 0.8
        filter = make_allpass(frequency, samplerate, q_factor)
        w0 = tau * frequency / samplerate
        _sin = sin(w0)
        _cos = cos(w0)
        alpha = _sin / (2 * q_factor)
        b0 = 1 - alpha
        b1 = -2 * _cos
        b2 = 1 + alpha
        assert filter.a_coeffs == [b2, b1, b0]
        assert filter.b_coeffs == [b0, b1, b2]

    @pytest.mark.negative
    def test_make_allpass_zero_frequency(self):
        frequency = 0
        samplerate = 48000
        q_factor = 0.8
        with pytest.raises(ZeroDivisionError):
            make_allpass(frequency, samplerate, q_factor)

    @pytest.mark.negative
    def test_make_allpass_zero_samplerate(self):
        frequency = 1000
        samplerate = 0
        q_factor = 0.8
        with pytest.raises(ZeroDivisionError):
            make_allpass(frequency, samplerate, q_factor)

    @pytest.mark.negative
    def test_make_allpass_zero_qfactor(self):
        frequency = 1000
        samplerate = 48000
        q_factor = 0
        with pytest.raises(ZeroDivisionError):
            make_allpass(frequency, samplerate, q_factor)

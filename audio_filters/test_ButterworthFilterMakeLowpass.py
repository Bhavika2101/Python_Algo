# ********RoostGPT********
"""
Test generated by RoostGPT for test python-unit--test using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=make_lowpass_c429b6062d
ROOST_METHOD_SIG_HASH=make_lowpass_c429b6062d

================================VULNERABILITIES================================
Vulnerability: Input Validation
Issue: The function 'make_lowpass' does not validate the input parameters. This can lead to unexpected behavior or crashes if incorrect values are passed.
Solution: Check the input parameters for validity. For example, ensure the 'frequency' and 'samplerate' are positive integers, and 'q_factor' is a positive float.

Vulnerability: Dependency Security
Issue: The code relies on a third-party package 'audio_filters'. If this package has vulnerabilities or is not maintained, it can expose the application to risks.
Solution: Ensure 'audio_filters' package is up-to-date and maintained by a reputable source. Consider alternatives if the package is deprecated or unmaintained.

================================================================================
Scenario 1: Validate the creation of a valid low-pass filter
Details:
  TestName: test_valid_lowpass_filter_creation
  Description: This test is intended to verify that the function can create a valid low-pass filter based on the provided parameters. This is the core functionality of the make_lowpass function.
Execution:
  Arrange: No specific setup required as we are testing the function directly.
  Act: Invoke the make_lowpass function with valid parameters for frequency, samplerate, and q_factor.
  Assert: Check that the returned object is an instance of IIRFilter, and the a_coeffs and b_coeffs match expected values.
Validation:
  This test is important to ensure that the function can correctly create a low-pass filter, which is the primary business requirement for this function. The expected result is derived from the calculation logic embedded in the function.

Scenario 2: Validate the function's behavior for zero frequency
Details:
  TestName: test_zero_frequency
  Description: This test is intended to verify the function's behavior when a zero frequency is provided.
Execution:
  Arrange: No specific setup required as we are testing the function directly.
  Act: Invoke the make_lowpass function with zero frequency, and valid values for samplerate and q_factor.
  Assert: Check that the returned filter's coefficients are as expected when frequency is zero.
Validation:
  This test is important to ensure that the function can handle edge cases correctly, in this case, zero frequency. The expected result is derived from the calculation logic embedded in the function.

Scenario 3: Validate the function's behavior for maximum frequency
Details:
  TestName: test_max_frequency
  Description: This test is intended to verify the function's behavior when the maximum possible frequency is provided.
Execution:
  Arrange: No specific setup required as we are testing the function directly.
  Act: Invoke the make_lowpass function with maximum frequency, and valid values for samplerate and q_factor.
  Assert: Check that the returned filter's coefficients are as expected when frequency is at maximum.
Validation:
  This test is important to ensure that the function can handle edge cases correctly, in this case, maximum frequency. The expected result is derived from the calculation logic embedded in the function.

Scenario 4: Validate the function's behavior for negative q_factor
Details:
  TestName: test_negative_q_factor
  Description: This test is intended to verify the function's behavior when a negative q_factor is provided.
Execution:
  Arrange: No specific setup required as we are testing the function directly.
  Act: Invoke the make_lowpass function with valid frequency, samplerate, and a negative q_factor.
  Assert: Check that the returned filter's coefficients are as expected when q_factor is negative.
Validation:
  This test is important to ensure that the function can handle edge cases correctly, in this case, a negative q_factor. The expected result is derived from the calculation logic embedded in the function.
"""

# ********RoostGPT********
import pytest
from math import cos, sin, sqrt, tau
from audio_filters.iir_filter import IIRFilter
from butterworth_filter import make_lowpass

class Test_ButterworthFilterMakeLowpass:
    
    @pytest.mark.regression
    def test_valid_lowpass_filter_creation(self):
        # Act
        filter = make_lowpass(1000, 48000)
        
        # Assert
        assert isinstance(filter, IIRFilter)
        assert filter.a_coeffs == [1.0922959556412573, -1.9828897227476208, 0.9077040443587427]
        assert filter.b_coeffs == [0.004277569313094809, 0.008555138626189618, 0.004277569313094809]
    
    @pytest.mark.edge
    def test_zero_frequency(self):
        # Act
        filter = make_lowpass(0, 48000)
        
        # Assert
        assert filter.a_coeffs == [1.0, 0.0, 0.0]
        assert filter.b_coeffs == [0.5, 1.0, 0.5]

    @pytest.mark.edge
    def test_max_frequency(self):
        # Act
        filter = make_lowpass(24000, 48000)
        
        # Assert
        assert filter.a_coeffs == [1.0, -2.0, 1.0]
        assert filter.b_coeffs == [0.0, 0.0, 0.0]

    @pytest.mark.edge
    def test_negative_q_factor(self):
        # Act
        filter = make_lowpass(1000, 48000, -1 / sqrt(2))
        
        # Assert
        assert filter.a_coeffs == [1.0, 0.0, 0.0]
        assert filter.b_coeffs == [0.5, 1.0, 0.5]

# ********RoostGPT********
"""
Test generated by RoostGPT for test python-unit--test using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=make_lowpass_c429b6062d
ROOST_METHOD_SIG_HASH=make_lowpass_c429b6062d

================================VULNERABILITIES================================
Vulnerability: Input validation (CWE-20)
Issue: The function make_lowpass does not check if the input parameters are of correct types and within the expected ranges. This can lead to unexpected behavior or crashes.
Solution: Add input validation checks at the start of the function to ensure that 'frequency' and 'samplerate' are integers, 'q_factor' is a float, and all are within expected ranges.

Vulnerability: Untrusted third-party package (CWE-829)
Issue: The code is using a third-party library 'audio_filters.iir_filter'. If this library is compromised or not properly maintained, it can pose serious security risks.
Solution: Ensure that the third-party libraries used in the code are trusted, well-maintained, and have been recently audited for security. If possible, consider using built-in Python libraries or modules instead.

================================================================================
Scenario 1: Validate the creation of a valid low-pass filter
Details:
  TestName: test_valid_lowpass_filter_creation
  Description: This test is intended to verify that the function can create a valid low-pass filter based on the provided parameters. This is the core functionality of the function and must operate as expected.
Execution:
  Arrange: Define a frequency, samplerate, and q_factor.
  Act: Invoke the function with the defined parameters.
  Assert: Check that the returned object is an instance of IIRFilter and that the coefficients match the expected values.
Validation:
  This test ensures that the function can create a low-pass filter as expected. The correctness of the coefficients is crucial to the filter's operation.

Scenario 2: Validate handling of zero frequency
Details:
  TestName: test_zero_frequency_handling
  Description: This test is intended to verify that the function can handle a zero frequency input. This is an edge case that may occur in certain scenarios.
Execution:
  Arrange: Define a frequency of zero, a samplerate, and a q_factor.
  Act: Invoke the function with the defined parameters.
  Assert: Check that the returned object is an instance of IIRFilter and that the coefficients match the expected values for a zero frequency.
Validation:
  This test ensures that the function can handle edge cases. It is important that the function not crash or produce invalid results when given a zero frequency.

Scenario 3: Validate handling of negative frequency
Details:
  TestName: test_negative_frequency_handling
  Description: This test is intended to verify that the function can handle a negative frequency input. This is an error condition that should be handled gracefully.
Execution:
  Arrange: Define a negative frequency, a samplerate, and a q_factor.
  Act: Invoke the function with the defined parameters.
  Assert: Check that the function raises an appropriate exception.
Validation:
  This test ensures that the function can handle error conditions. It is important that the function not crash or produce invalid results when given a negative frequency.

Scenario 4: Validate handling of zero samplerate
Details:
  TestName: test_zero_samplerate_handling
  Description: This test is intended to verify that the function can handle a zero samplerate input. This is an error condition that should be handled gracefully.
Execution:
  Arrange: Define a frequency, a samplerate of zero, and a q_factor.
  Act: Invoke the function with the defined parameters.
  Assert: Check that the function raises an appropriate exception.
Validation:
  This test ensures that the function can handle error conditions. It is important that the function not crash or produce invalid results when given a zero samplerate.

Scenario 5: Validate handling of negative q_factor
Details:
  TestName: test_negative_q_factor_handling
  Description: This test is intended to verify that the function can handle a negative q_factor input. This is an error condition that should be handled gracefully.
Execution:
  Arrange: Define a frequency, a samplerate, and a negative q_factor.
  Act: Invoke the function with the defined parameters.
  Assert: Check that the function raises an appropriate exception.
Validation:
  This test ensures that the function can handle error conditions. It is important that the function not crash or produce invalid results when given a negative q_factor.
"""

# ********RoostGPT********
import pytest
from math import cos, sin, sqrt, tau
from audio_filters.iir_filter import IIRFilter
from audio_filters.butterworth_filter import make_lowpass

class Test_ButterworthFilterMakeLowpass:

    def test_valid_lowpass_filter_creation(self):
        # Arrange
        frequency = 1000
        samplerate = 48000
        q_factor = 1 / sqrt(2)

        # Act
        result = make_lowpass(frequency, samplerate, q_factor)

        # Assert
        assert isinstance(result, IIRFilter)
        assert result.a_coeffs == pytest.approx([1.0922959556412573, -1.9828897227476208, 0.9077040443587427], 0.0001)
        assert result.b_coeffs == pytest.approx([0.004277569313094809, 0.008555138626189618, 0.004277569313094809], 0.0001)

    def test_zero_frequency_handling(self):
        # Arrange
        frequency = 0
        samplerate = 48000
        q_factor = 1 / sqrt(2)

        # Act
        result = make_lowpass(frequency, samplerate, q_factor)

        # Assert
        assert isinstance(result, IIRFilter)
        assert result.a_coeffs == pytest.approx([1.0, 0.0, -1.0], 0.0001)
        assert result.b_coeffs == pytest.approx([0.0, 0.0, 0.0], 0.0001)

    def test_negative_frequency_handling(self):
        # Arrange
        frequency = -1000
        samplerate = 48000
        q_factor = 1 / sqrt(2)

        # Act & Assert
        with pytest.raises(ValueError):
            make_lowpass(frequency, samplerate, q_factor)

    def test_zero_samplerate_handling(self):
        # Arrange
        frequency = 1000
        samplerate = 0
        q_factor = 1 / sqrt(2)

        # Act & Assert
        with pytest.raises(ZeroDivisionError):
            make_lowpass(frequency, samplerate, q_factor)

    def test_negative_q_factor_handling(self):
        # Arrange
        frequency = 1000
        samplerate = 48000
        q_factor = -1 / sqrt(2)

        # Act & Assert
        with pytest.raises(ValueError):
            make_lowpass(frequency, samplerate, q_factor)

# ********RoostGPT********
"""
Test generated by RoostGPT for test python-unit--test using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=make_lowpass_c429b6062d
ROOST_METHOD_SIG_HASH=make_lowpass_c429b6062d

Scenario 1: Validate the creation of a valid low-pass filter
Details:
  TestName: test_valid_lowpass_filter_creation
  Description: This test is intended to verify that the function can create a valid low-pass filter based on the provided parameters. This is the core functionality of the function and must operate as expected.
Execution:
  Arrange: Define a frequency, samplerate, and q_factor.
  Act: Call the function with the defined parameters.
  Assert: Check that the returned object is an instance of IIRFilter and that the coefficients match the expected values.
Validation:
  This test ensures that the function can create a low-pass filter, which is its primary purpose. The correct coefficients are essential for the filter to function correctly.

Scenario 2: Validate behavior with minimum frequency
Details:
  TestName: test_lowpass_filter_with_min_frequency
  Description: This test is intended to check the function's behavior when the minimum possible frequency (0) is provided. 
Execution:
  Arrange: Define the frequency as 0, and specify a samplerate and q_factor.
  Act: Call the function with the defined parameters.
  Assert: Check that the returned object is an instance of IIRFilter and that the coefficients match the expected values.
Validation:
  This test ensures that the function handles the edge case of a frequency of 0, which could potentially lead to divide-by-zero errors or other issues. The function should still return a valid filter in this case.

Scenario 3: Validate behavior with maximum frequency
Details:
  TestName: test_lowpass_filter_with_max_frequency
  Description: This test is intended to check the function's behavior when the maximum possible frequency (samplerate/2) is provided.
Execution:
  Arrange: Define the frequency as samplerate/2, and specify a samplerate and q_factor.
  Act: Call the function with the defined parameters.
  Assert: Check that the returned object is an instance of IIRFilter and that the coefficients match the expected values.
Validation:
  This test ensures that the function handles the edge case of a frequency equal to the Nyquist frequency (samplerate/2), which is the maximum frequency that can be accurately represented. The function should still return a valid filter in this case.

Scenario 4: Validate behavior with varying q_factors
Details:
  TestName: test_lowpass_filter_with_varying_q_factors
  Description: This test is intended to verify that the function can create valid filters with different q_factors, which control the filter's bandwidth and resonance.
Execution:
  Arrange: Define a frequency and samplerate, and specify multiple different q_factors.
  Act: Call the function with the defined parameters for each q_factor.
  Assert: Check that the returned objects are instances of IIRFilter and that the coefficients match the expected values for each q_factor.
Validation:
  This test ensures that the function can create filters with different q_factors, allowing for different filter characteristics. This is an important part of the function's ability to create a variety of filters.
"""

# ********RoostGPT********
import pytest
from math import cos, sin, sqrt, tau
from audio_filters.iir_filter import IIRFilter
from butterworth_filter import make_lowpass

class Test_ButterworthFilterMakeLowpass:

    @pytest.mark.positive
    def test_valid_lowpass_filter_creation(self):
        # Arrange
        frequency = 1000
        samplerate = 48000
        q_factor = 1 / sqrt(2)

        # Act
        result = make_lowpass(frequency, samplerate, q_factor)

        # Assert
        assert isinstance(result, IIRFilter)
        w0 = tau * frequency / samplerate
        _sin = sin(w0)
        _cos = cos(w0)
        alpha = _sin / (2 * q_factor)
        b0 = (1 - _cos) / 2
        b1 = 1 - _cos
        a0 = 1 + alpha
        a1 = -2 * _cos
        a2 = 1 - alpha
        assert result.a_coeffs == [a0, a1, a2]
        assert result.b_coeffs == [b0, b1, b0]
    
    @pytest.mark.negative
    def test_lowpass_filter_with_min_frequency(self):
        # Arrange
        frequency = 0
        samplerate = 48000
        q_factor = 1 / sqrt(2)

        # Act
        result = make_lowpass(frequency, samplerate, q_factor)

        # Assert
        assert isinstance(result, IIRFilter)
        w0 = tau * frequency / samplerate
        _sin = sin(w0)
        _cos = cos(w0)
        alpha = _sin / (2 * q_factor)
        b0 = (1 - _cos) / 2
        b1 = 1 - _cos
        a0 = 1 + alpha
        a1 = -2 * _cos
        a2 = 1 - alpha
        assert result.a_coeffs == [a0, a1, a2]
        assert result.b_coeffs == [b0, b1, b0]

    @pytest.mark.negative
    def test_lowpass_filter_with_max_frequency(self):
        # Arrange
        samplerate = 48000
        frequency = samplerate / 2
        q_factor = 1 / sqrt(2)

        # Act
        result = make_lowpass(frequency, samplerate, q_factor)

        # Assert
        assert isinstance(result, IIRFilter)
        w0 = tau * frequency / samplerate
        _sin = sin(w0)
        _cos = cos(w0)
        alpha = _sin / (2 * q_factor)
        b0 = (1 - _cos) / 2
        b1 = 1 - _cos
        a0 = 1 + alpha
        a1 = -2 * _cos
        a2 = 1 - alpha
        assert result.a_coeffs == [a0, a1, a2]
        assert result.b_coeffs == [b0, b1, b0]

    @pytest.mark.regression
    @pytest.mark.parametrize('q_factor', [0.5, 1, sqrt(2), 2, 3])
    def test_lowpass_filter_with_varying_q_factors(self, q_factor):
        # Arrange
        frequency = 1000
        samplerate = 48000

        # Act
        result = make_lowpass(frequency, samplerate, q_factor)

        # Assert
        assert isinstance(result, IIRFilter)
        w0 = tau * frequency / samplerate
        _sin = sin(w0)
        _cos = cos(w0)
        alpha = _sin / (2 * q_factor)
        b0 = (1 - _cos) / 2
        b1 = 1 - _cos
        a0 = 1 + alpha
        a1 = -2 * _cos
        a2 = 1 - alpha
        assert result.a_coeffs == [a0, a1, a2]
        assert result.b_coeffs == [b0, b1, b0]

# ********RoostGPT********
"""
Test generated by RoostGPT for test python-unit--test using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=make_peak_c1329dbc09
ROOST_METHOD_SIG_HASH=make_peak_c1329dbc09

================================VULNERABILITIES================================
Vulnerability: Untrusted Input (CWE-20)
Issue: If the frequency, samplerate, gain_db, or q_factor are provided by an untrusted source, they could potentially cause the program to behave in unexpected ways.
Solution: Validate and sanitize all input. Ensure that the provided values are within expected ranges before using them.

Vulnerability: Denial of Service (CWE-400)
Issue: If an attacker can control the input parameters, they may be able to cause the program to consume excessive resources, leading to a Denial of Service.
Solution: Implement resource usage limits and request rate limiting to prevent excessive resource consumption.

================================================================================
Scenario 1: Test that the function correctly creates an IIRFilter object with the correct coefficients for a given set of parameters.
Details:
  TestName: test_make_peak_correct_coefficients
  Description: This test verifies that the function correctly calculates and sets the coefficients of the IIRFilter object it creates based on the input parameters.
Execution:
  Arrange: Define a set of input parameters (frequency, samplerate, gain_db, q_factor).
  Act: Call the make_peak function with these parameters.
  Assert: Check that the IIRFilter object returned has the expected coefficients.
Validation:
  This test is important because the coefficients of the IIRFilter object determine its behavior, so it's critical that they are calculated and set correctly.

Scenario 2: Test that the function correctly handles a gain_db of zero.
Details:
  TestName: test_make_peak_zero_gain
  Description: This test verifies that the function correctly handles a gain_db of zero, which should result in an IIRFilter object with no gain.
Execution:
  Arrange: Define a set of input parameters with gain_db set to zero.
  Act: Call the make_peak function with these parameters.
  Assert: Check that the IIRFilter object returned has the expected coefficients, indicating no gain.
Validation:
  This test is important because a gain_db of zero is a special case that may not be handled correctly by all implementations.

Scenario 3: Test that the function correctly handles a negative gain_db.
Details:
  TestName: test_make_peak_negative_gain
  Description: This test verifies that the function correctly handles a negative gain_db, which should result in an IIRFilter object with a gain less than one.
Execution:
  Arrange: Define a set of input parameters with gain_db set to a negative value.
  Act: Call the make_peak function with these parameters.
  Assert: Check that the IIRFilter object returned has the expected coefficients, indicating a gain less than one.
Validation:
  This test is important because a negative gain_db is a valid input that should result in a specific behavior.

Scenario 4: Test that the function correctly handles a frequency that is higher than the samplerate.
Details:
  TestName: test_make_peak_high_frequency
  Description: This test verifies that the function correctly handles a frequency that is higher than the samplerate, which should result in an IIRFilter object with coefficients indicating a high-pass filter.
Execution:
  Arrange: Define a set of input parameters with frequency set to a value higher than the samplerate.
  Act: Call the make_peak function with these parameters.
  Assert: Check that the IIRFilter object returned has the expected coefficients, indicating a high-pass filter.
Validation:
  This test is important because a frequency higher than the samplerate is a valid input that should result in a specific behavior.
"""

# ********RoostGPT********
import pytest
from math import cos, sin, sqrt, tau
from audio_filters.iir_filter import IIRFilter
from butterworth_filter import make_peak

class Test_ButterworthFilterMakePeak:
    @pytest.mark.regression
    def test_make_peak_correct_coefficients(self):
        # Arrange
        frequency = 1000
        samplerate = 48000
        gain_db = 6
        q_factor = 1 / sqrt(2)

        # Act
        filter = make_peak(frequency, samplerate, gain_db, q_factor)
        
        # Assert
        w0 = tau * frequency / samplerate
        _sin = sin(w0)
        _cos = cos(w0)
        alpha = _sin / (2 * q_factor)
        big_a = 10 ** (gain_db / 40)
        expected_coefficients = [1 + alpha / big_a, -2 * _cos, 1 - alpha / big_a, 1 + alpha * big_a, -2 * _cos, 1 - alpha * big_a]
        assert filter.a_coeffs + filter.b_coeffs == pytest.approx(expected_coefficients)

    @pytest.mark.regression
    def test_make_peak_zero_gain(self):
        # Arrange
        frequency = 1000
        samplerate = 48000
        gain_db = 0
        q_factor = 1 / sqrt(2)

        # Act
        filter = make_peak(frequency, samplerate, gain_db, q_factor)

        # Assert
        assert filter.a_coeffs + filter.b_coeffs == pytest.approx([1.0, -1.9828897227476208, 0.9346594672880666, 1.0, -1.9828897227476208, 0.9346594672880666])

    @pytest.mark.regression
    def test_make_peak_negative_gain(self):
        # Arrange
        frequency = 1000
        samplerate = 48000
        gain_db = -6
        q_factor = 1 / sqrt(2)

        # Act
        filter = make_peak(frequency, samplerate, gain_db, q_factor)

        # Assert
        assert filter.a_coeffs + filter.b_coeffs == pytest.approx([1.0653405327119334, -1.9828897227476208, 0.9346594672880666, 0.8696284974398878, -1.9828897227476208, 1.1303715025601122])

    @pytest.mark.regression
    def test_make_peak_high_frequency(self):
        # Arrange
        frequency = 96000
        samplerate = 48000
        gain_db = 6
        q_factor = 1 / sqrt(2)

        # Act
        filter = make_peak(frequency, samplerate, gain_db, q_factor)

        # Assert
        assert filter.a_coeffs + filter.b_coeffs == pytest.approx([1.0, -2.0, 1.0, 1.0, -2.0, 1.0])

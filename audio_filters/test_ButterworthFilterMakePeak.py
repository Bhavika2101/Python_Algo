# ********RoostGPT********
"""
Test generated by RoostGPT for test python-unit--test using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=make_peak_c1329dbc09
ROOST_METHOD_SIG_HASH=make_peak_c1329dbc09

================================VULNERABILITIES================================
Vulnerability: Input Validation
Issue: The function make_peak does not validate its input parameters. This might lead to unexpected behavior or crashes if the function is called with invalid parameters, e.g., negative or zero values.
Solution: Add checks at the beginning of the function to ensure that the input parameters are within the expected ranges and types.

Vulnerability: Error Handling
Issue: There are no try/except blocks in the function to handle potential errors, such as division by zero or math domain errors.
Solution: Wrap critical operations in try/except blocks and handle exceptions appropriately to prevent the application from crashing.

================================================================================
Scenario 1: Test that the function correctly creates an IIRFilter object with the correct coefficients for a given set of parameters.
Details:
  TestName: test_make_peak_correct_coefficients
  Description: This test verifies that the function correctly calculates and sets the coefficients of the IIRFilter object it creates based on the input parameters.
Execution:
  Arrange: Define a set of input parameters (frequency, samplerate, gain_db, q_factor).
  Act: Call the make_peak function with these parameters.
  Assert: Check that the IIRFilter object returned has the correct coefficients.
Validation:
  This test is important because the coefficients of the IIRFilter object determine its behavior, and it's crucial that they are calculated correctly based on the input parameters.

Scenario 2: Test that the function handles a gain of 0 dB correctly.
Details:
  TestName: test_make_peak_zero_gain
  Description: This test verifies that the function correctly handles a gain of 0 dB, which should result in an unmodified signal.
Execution:
  Arrange: Define a set of input parameters with a gain of 0 dB.
  Act: Call the make_peak function with these parameters.
  Assert: Check that the IIRFilter object returned has coefficients that will result in an unmodified signal.
Validation:
  This test is important because a gain of 0 dB is a common use case that should result in an unmodified signal, and it's crucial that the function handles this case correctly.

Scenario 3: Test that the function handles a negative gain correctly.
Details:
  TestName: test_make_peak_negative_gain
  Description: This test verifies that the function correctly handles a negative gain, which should result in a signal reduction.
Execution:
  Arrange: Define a set of input parameters with a negative gain.
  Act: Call the make_peak function with these parameters.
  Assert: Check that the IIRFilter object returned has coefficients that will result in a reduced signal.
Validation:
  This test is important because a negative gain is a valid use case that should result in a reduced signal, and it's crucial that the function handles this case correctly.

Scenario 4: Test that the function handles a frequency of 0 Hz correctly.
Details:
  TestName: test_make_peak_zero_frequency
  Description: This test verifies that the function correctly handles a frequency of 0 Hz, which should result in a flat response.
Execution:
  Arrange: Define a set of input parameters with a frequency of 0 Hz.
  Act: Call the make_peak function with these parameters.
  Assert: Check that the IIRFilter object returned has coefficients that will result in a flat response.
Validation:
  This test is important because a frequency of 0 Hz is a valid use case that should result in a flat response, and it's crucial that the function handles this case correctly.

Scenario 5: Test that the function handles a frequency equal to the samplerate correctly.
Details:
  TestName: test_make_peak_frequency_equals_samplerate
  Description: This test verifies that the function correctly handles a frequency equal to the samplerate, which should result in a notch filter.
Execution:
  Arrange: Define a set of input parameters with a frequency equal to the samplerate.
  Act: Call the make_peak function with these parameters.
  Assert: Check that the IIRFilter object returned has coefficients that will result in a notch filter.
Validation:
  This test is important because a frequency equal to the samplerate is a valid use case that should result in a notch filter, and it's crucial that the function handles this case correctly.
"""

# ********RoostGPT********
import pytest
from math import cos, sin, sqrt, tau
from audio_filters.iir_filter import IIRFilter
from audio_filters.butterworth_filter import make_peak

class Test_ButterworthFilterMakePeak:

    @pytest.mark.regression
    def test_make_peak_correct_coefficients(self):
        # Arrange
        frequency = 1000
        samplerate = 48000
        gain_db = 6
        q_factor = 1 / sqrt(2)

        # Act
        filter = make_peak(frequency, samplerate, gain_db, q_factor)

        # Assert
        assert isinstance(filter, IIRFilter)
        assert len(filter.a_coeffs) == 3
        assert len(filter.b_coeffs) == 3

    @pytest.mark.regression
    def test_make_peak_zero_gain(self):
        # Arrange
        frequency = 1000
        samplerate = 48000
        gain_db = 0
        q_factor = 1 / sqrt(2)

        # Act
        filter = make_peak(frequency, samplerate, gain_db, q_factor)

        # Assert
        assert isinstance(filter, IIRFilter)
        assert len(filter.a_coeffs) == 3
        assert len(filter.b_coeffs) == 3

    @pytest.mark.regression
    def test_make_peak_negative_gain(self):
        # Arrange
        frequency = 1000
        samplerate = 48000
        gain_db = -6
        q_factor = 1 / sqrt(2)

        # Act
        filter = make_peak(frequency, samplerate, gain_db, q_factor)

        # Assert
        assert isinstance(filter, IIRFilter)
        assert len(filter.a_coeffs) == 3
        assert len(filter.b_coeffs) == 3

    @pytest.mark.regression
    def test_make_peak_zero_frequency(self):
        # Arrange
        frequency = 0
        samplerate = 48000
        gain_db = 6
        q_factor = 1 / sqrt(2)

        # Act
        filter = make_peak(frequency, samplerate, gain_db, q_factor)

        # Assert
        assert isinstance(filter, IIRFilter)
        assert len(filter.a_coeffs) == 3
        assert len(filter.b_coeffs) == 3

    @pytest.mark.regression
    def test_make_peak_frequency_equals_samplerate(self):
        # Arrange
        frequency = 48000
        samplerate = 48000
        gain_db = 6
        q_factor = 1 / sqrt(2)

        # Act
        filter = make_peak(frequency, samplerate, gain_db, q_factor)

        # Assert
        assert isinstance(filter, IIRFilter)
        assert len(filter.a_coeffs) == 3
        assert len(filter.b_coeffs) == 3

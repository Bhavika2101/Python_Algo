# ********RoostGPT********
"""
Test generated by RoostGPT for test python-unit--test using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=make_peak_c1329dbc09
ROOST_METHOD_SIG_HASH=make_peak_c1329dbc09

================================VULNERABILITIES================================
Vulnerability: Input Validation
Issue: The function 'make_peak' does not validate the input parameters. This can lead to unexpected behavior or crashes if the function is called with invalid parameters.
Solution: Add input validation checks to ensure the parameters 'frequency', 'samplerate', 'gain_db', and 'q_factor' are of the correct type and within expected ranges.

Vulnerability: Dependency Security
Issue: The code relies on the 'audio_filters.iir_filter' package. If this package has any vulnerabilities or is not maintained, it could introduce security risks.
Solution: Ensure that all dependencies are up-to-date, actively maintained, and free of known vulnerabilities. Consider using a tool like PyUp or GitHub's Dependabot to automatically check for updates and vulnerabilities in dependencies.

================================================================================
Scenario 1: Test that the function correctly creates an IIRFilter object with the correct coefficients for a given set of parameters.
Details:
  TestName: test_make_peak_correct_coefficients
  Description: This test verifies that the function correctly calculates and sets the coefficients of the IIRFilter object it creates based on the input parameters.
Execution:
  Arrange: Define a set of input parameters (frequency, samplerate, gain_db, q_factor).
  Act: Call the make_peak function with these parameters.
  Assert: Check that the IIRFilter object returned has the correct coefficients.
Validation:
  This test is important because the coefficients of the IIRFilter object determine its behavior, and it's crucial that they are calculated correctly based on the input parameters.

Scenario 2: Test that the function handles a gain of 0 dB correctly.
Details:
  TestName: test_make_peak_zero_gain
  Description: This test verifies that the function correctly handles a gain of 0 dB, which should result in an unmodified signal.
Execution:
  Arrange: Define a set of input parameters with a gain of 0 dB.
  Act: Call the make_peak function with these parameters.
  Assert: Check that the IIRFilter object returned has coefficients that will result in an unmodified signal.
Validation:
  This test is important because a gain of 0 dB is a common use case that should result in an unmodified signal, and it's crucial that the function handles this case correctly.

Scenario 3: Test that the function handles a frequency equal to the samplerate correctly.
Details:
  TestName: test_make_peak_frequency_equals_samplerate
  Description: This test verifies that the function correctly handles a frequency that is equal to the samplerate, which should result in a 0 Hz signal.
Execution:
  Arrange: Define a set of input parameters with a frequency equal to the samplerate.
  Act: Call the make_peak function with these parameters.
  Assert: Check that the IIRFilter object returned has coefficients that will result in a 0 Hz signal.
Validation:
  This test is important because a frequency equal to the samplerate is a boundary case that should result in a 0 Hz signal, and it's crucial that the function handles this case correctly.

Scenario 4: Test that the function handles a negative gain correctly.
Details:
  TestName: test_make_peak_negative_gain
  Description: This test verifies that the function correctly handles a negative gain, which should result in a signal that is attenuated by the absolute value of the gain.
Execution:
  Arrange: Define a set of input parameters with a negative gain.
  Act: Call the make_peak function with these parameters.
  Assert: Check that the IIRFilter object returned has coefficients that will result in a signal that is attenuated by the absolute value of the gain.
Validation:
  This test is important because negative gains are a valid use case that should result in an attenuated signal, and it's crucial that the function handles this case correctly.
"""

# ********RoostGPT********
import pytest
from math import cos, sin, sqrt, tau
from audio_filters.iir_filter import IIRFilter
from butterworth_filter import make_peak

class Test_ButterworthFilterMakePeak:
    @pytest.mark.regression
    def test_make_peak_correct_coefficients(self):
        frequency = 1000
        samplerate = 48000
        gain_db = 6
        q_factor = 1 / sqrt(2)

        expected_filter = IIRFilter(2)
        w0 = tau * frequency / samplerate
        _sin = sin(w0)
        _cos = cos(w0)
        alpha = _sin / (2 * q_factor)
        big_a = 10 ** (gain_db / 40)

        b0 = 1 + alpha * big_a
        b1 = -2 * _cos
        b2 = 1 - alpha * big_a
        a0 = 1 + alpha / big_a
        a1 = -2 * _cos
        a2 = 1 - alpha / big_a

        expected_filter.set_coefficients([a0, a1, a2], [b0, b1, b2])

        result_filter = make_peak(frequency, samplerate, gain_db, q_factor)

        assert result_filter.a_coeffs == expected_filter.a_coeffs
        assert result_filter.b_coeffs == expected_filter.b_coeffs

    @pytest.mark.valid
    def test_make_peak_zero_gain(self):
        frequency = 1000
        samplerate = 48000
        gain_db = 0
        q_factor = 1 / sqrt(2)

        expected_filter = IIRFilter(2)
        expected_filter.set_coefficients([1, 0, 0], [1, 0, 0])

        result_filter = make_peak(frequency, samplerate, gain_db, q_factor)

        assert result_filter.a_coeffs == expected_filter.a_coeffs
        assert result_filter.b_coeffs == expected_filter.b_coeffs

    @pytest.mark.boundary
    def test_make_peak_frequency_equals_samplerate(self):
        frequency = 48000
        samplerate = 48000
        gain_db = 6
        q_factor = 1 / sqrt(2)

        expected_filter = IIRFilter(2)
        expected_filter.set_coefficients([1, 0, 0], [1, 0, 0])

        result_filter = make_peak(frequency, samplerate, gain_db, q_factor)

        assert result_filter.a_coeffs == expected_filter.a_coeffs
        assert result_filter.b_coeffs == expected_filter.b_coeffs

    @pytest.mark.valid
    def test_make_peak_negative_gain(self):
        frequency = 1000
        samplerate = 48000
        gain_db = -6
        q_factor = 1 / sqrt(2)

        expected_filter = IIRFilter(2)
        w0 = tau * frequency / samplerate
        _sin = sin(w0)
        _cos = cos(w0)
        alpha = _sin / (2 * q_factor)
        big_a = 10 ** (gain_db / 40)

        b0 = 1 + alpha * big_a
        b1 = -2 * _cos
        b2 = 1 - alpha * big_a
        a0 = 1 + alpha / big_a
        a1 = -2 * _cos
        a2 = 1 - alpha / big_a

        expected_filter.set_coefficients([a0, a1, a2], [b0, b1, b2])

        result_filter = make_peak(frequency, samplerate, gain_db, q_factor)

        assert result_filter.a_coeffs == expected_filter.a_coeffs
        assert result_filter.b_coeffs == expected_filter.b_coeffs

# ********RoostGPT********
"""
Test generated by RoostGPT for test also-ciphers-python-unit using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=generate_key_ed78bd6770
ROOST_METHOD_SIG_HASH=generate_key_d70386d4cc

Scenario 1: Validating correct generation of public and private key
Details:
  TestName: test_generate_key
  Description: This test is intended to verify if the function correctly generates the public and private keys with the given key size.
Execution:
  Arrange: Define a fixed key size and seed the random number generator for repeatability.
  Act: Call the generate_key function with the defined key size.
  Assert: Check if the public and private keys are generated correctly and match the expected values.
Validation:
  The importance of this test is to ensure that the function can generate valid keys. The correct generation of keys is crucial for the functioning of the encryption and decryption process.

Scenario 2: Validating the uniqueness of public and private keys
Details:
  TestName: test_generate_key_uniqueness
  Description: This test is intended to verify if the function generates unique public and private keys each time it is called.
Execution:
  Arrange: Define a fixed key size and seed the random number generator for repeatability.
  Act: Call the generate_key function with the defined key size multiple times.
  Assert: Check if the generated keys are unique each time the function is called.
Validation:
  It is important to ensure that the function generates unique keys each time to maintain the security of the encryption and decryption process.

Scenario 3: Validating the key size of the generated keys
Details:
  TestName: test_generate_key_size
  Description: This test is intended to verify if the function generates keys of the correct size as defined in the input.
Execution:
  Arrange: Define a fixed key size.
  Act: Call the generate_key function with the defined key size.
  Assert: Check if the size of the generated keys matches the defined key size.
Validation:
  The importance of this test is to ensure that the keys are of the correct size. The key size is a critical parameter for the security of the encryption and decryption process.

Scenario 4: Validating the generation of prime numbers in the function
Details:
  TestName: test_generate_key_prime_numbers
  Description: This test is intended to verify if the function correctly generates prime numbers for the calculation of keys.
Execution:
  Arrange: Define a fixed key size.
  Act: Call the generate_key function with the defined key size.
  Assert: Check if the prime numbers used in the function are indeed prime.
Validation:
  The importance of this test is to ensure that the function correctly generates prime numbers. The use of prime numbers is a fundamental aspect of the RSA algorithm, which this function is based on.
"""

# ********RoostGPT********
import os
import pytest
import random
import sys
from ciphers.rsa_key_generator import generate_key
from maths.greatest_common_divisor import gcd_by_iterative

class Test_RsaKeyGeneratorGenerateKey:

    @pytest.mark.regression
    def test_generate_key(self):
        random.seed(42)  # for repeatability
        key_size = 8
        public_key, private_key = generate_key(key_size)
        assert public_key == (26569, 239)
        assert private_key == (26569, 2855)

    @pytest.mark.regression
    def test_generate_key_uniqueness(self):
        key_size = 8
        random.seed(42)  # for repeatability
        public_key_1, private_key_1 = generate_key(key_size)
        random.seed(24)  # for repeatability
        public_key_2, private_key_2 = generate_key(key_size)
        assert public_key_1 != public_key_2
        assert private_key_1 != private_key_2

    @pytest.mark.regression
    def test_generate_key_size(self):
        key_size = 8
        public_key, private_key = generate_key(key_size)
        assert len(bin(public_key[0])[2:]) == key_size
        assert len(bin(private_key[0])[2:]) == key_size

    @pytest.mark.regression
    def test_generate_key_prime_numbers(self):
        key_size = 8
        public_key, private_key = generate_key(key_size)
        n = public_key[0]
        assert gcd_by_iterative(n, (public_key[1] - 1) * (private_key[1] - 1)) == 1
